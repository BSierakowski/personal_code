(define (double n) (* n 2))

(define (abs x)
  (cond ((< x 0) (- x))
        ((>= x 0) x)))

;; Exercise 1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

;; Exercise 1.3
(define (sum-square-smallest a b c)
  (cond ((= a (min a b c)) (+ (* b b) (* c c)))
        ((= b (min a b c)) (+ (* a a) (* c c)))
        ((= c (min a b c)) (+ (* a a) (* b b)))))

;; Exercise 1.4
(define (a-plus-abs-b a b)
  ;; if b > 0, add the two numbers
  ;; else      subtract them
  ((if (> b 0) + -) a b))

;; Exercise 1.5
;; In an applicative order interpreter, the definition will loop infinitely
;; when trying to evaluate p in order to give "test" its second argument. In
;; a normal order interpreter, p will never be evaluated because it's never 
;; needed. (So for example, this is completely legal Haskell).

;; Exercise 1.6
;; If is lazy; (if test a b) only evaluates b if "test" is false.

;; Excercise 1.7 - Newton's Method
(define (sqrt x) (sqrt-iter 1.0 0.0 x))

(define (sqrt-iter guess oldguess x)
  (if (gooder-enough? guess oldguess)
      guess
      (sqrt-iter (improve guess x) guess
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x) (* x x))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

;; good-enough? performs poorly with big numbers:
;; (sqrt-iter 1 99999999) runs forever
;; and poorly with small numbers, where .001 off is not a good guess:
;; (sqrt-iter 1 .0001)
;; returns .0323, when the correct answer is .01

;;so we'll define a better one:
(define (gooder-enough? guess oldguess)
  (< (abs (/ (- guess oldguess) guess)) .001))

;; and it's better:
;; > (sqrt .0001)
;; 0.010000000025490743
;; > (sqrt 99999999)
;; 9999.999950082463

(define (cbrt x) (newtons3 1.0 0.0 x))

(define (newtons3 guess oldguess x)
  (if (gooder-enough? guess oldguess)
      guess
      (newtons3 (improve3 guess x) guess x)))

(define (improve3 guess x) 
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

;; Exercise 1.9
;; We'll call the first one +' and the second one +* , and use 4 + 4 as our
;; example:
;; 4 +' 4
;; (inc (+' 3 4))
;; (inc (inc (+' 2 4)))
;; (inc (inc (inc (+' 1 4))))
;; (inc (inc (inc (inc (+' 0 4)))))
;; (inc (inc (inc (5))))
;; 8

;; 4 +* 4
;; (+* 3 5)
;; (+* 2 6)
;; (+* 1 7)
;; (+* 0 8)
;; 8

;; Exercise 1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

;; A 0 n == 2y
;; A 1 0 == 0
;; A 1 1 == 2
;; A 1 n == 2**n (when n > 0)
;; A 2 n == Power Tower(2 n)

;; Exercise 1.11
;; The recursive version:
(define (f n)
  (cond ((< n 3) n)
        (#t (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))))
;; boy am I glad I have syntax highlighting for those )'s...

(define (f2 n)
  (cond ((< n 3) n)
        (#t (f2-iter n 0 1 2))))

(define (f2-iter n a b c)
  (cond ((< n 3) c)
        (#t (f2-iter (- n 1) b c (+ c (* 2 b) (* 3 a))))))

;; Exercise 1.12 generate n rows of pascal triangle
(define (pascal row col)
  (cond ((or (= 0 col) (= row col)) 1)
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))

;; I was not able to come up with this myself, this answer is
;; from http://www.kendyck.com/archives/2005/03/22/solution-to-sicp-exercise-112/ .
;; In my defense, I took "computes elements of Pascal's triangle by means of
;;  a recursive process" to mean that the function should output a stream
;; of pascal numbers. I simply didn't see how that was possible given the tools
;; so far in the book, and I still don't (though I'm nearly sure it is).

;;Exercise 1.13
;; I gave up; there's another beautiful answer at 
;; http://www.kendyck.com/archives/2005/04/24/solution-to-sicp-exercise-113/#comment-19466
;; Nicely formatted in MathML, no less.

;; Exercise 1.14
;; Draw the tree illustrating the process generated by the count-change procedure of section 1.2.2 in making change for 11 cents.

(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

;; (count-change 11)
;; (cc 11 5)
;; (cc 11 4) + (cc -39 5) => 0
;; (+ (cc 11 3) (cc -14 4) => 0)
;; (+ (cc 11 2) (cc 1 3))
;; (+ (+ (cc 11 1) (cc 6 2)) (+ (cc 1 2) (cc -9 2) => 0))
;; (+ (+ (+ (cc 11 0) => 0 (cc 10 1)) (+ (cc 6 1) (cc 1 2))) (cc 1 1))
;; (+ (+ (+ (cc 10 0) => 0 (cc 9 1)) ...
;;           ^ this pattern continues
;;             untill (cc 0 1) => 1
;; (+ (+ (+ 1 (+ (cc 6 1) (cc 1 2))) 1)
;;                ^ this continues until 
;;                  (cc 0 1) => 1, as above
;; (+ (+ (+ 1 (+ 1 (cc 1 2)))) 1)
;; (+ (+ (+ 1 (+ 1 (+ (cc 1 1) => 1 as above (cc -4 2) => 0)))) 1)
;; (+ (+ (+ 1 (+ 1 (+ 1)))) 1)
;; => 4
;;
;; my more detailed notes show that it takes 54 steps to generate this answer.
;; if we want to really show the order of growth in space/steps, we'll need to
;; implement an instrumented version of the code.
;;
;; One thing we *can* say about it is that the space and steps grow together, since
;; each invocation of (cc ...) does 1 step: either return an int or add 2 other
;; (cc ...)s together; thus we can implement a single counter:
(define invocations 0)
(define (count-change-invocations min max)
  (cond (< min max) ((count-change-instrument min)
                     (print min max) ;; this never prints?
                     (print invocations) ;; XXX: this function doesn't work
                     (count-change-invocations (+ min 1) max))))
(define (count-change-instrument amount)
  (set! invocations 0)
  (cc2 amount 5))
(define (cc2 amount kinds-of-coins)
  ;; increment our invocations counter
  (set! invocations (+ invocations 1))
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc2 amount
                     (- kinds-of-coins 1))
                 (cc2 (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))